
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
1. INTRODUCCI√ìN
La capacidad de resolver problemas de √°mbito general es una cualidad inherente de la raza
humana que proviene del proceso de razonamiento, el cual puede definirse c√≥mo:
La facultad que permite resolver problemas, extraer conclusiones y aprender
de manera consciente de los hechos, estableciendo conexiones causales y
l√≥gicas necesarias entre ellos.
La capacidad de razonar nos ha permitido evolucionar hasta el punto de tener la capacidad de
buscar diferentes formas de crear sistemas que sean capaces de imitar nuestro modelo de
razonamiento o exhibir procesos de razonamiento similares a los nuestros a la hora de resolver
los diferentes problemas que nos encontramos en el entorno o que generamos. Esta b√∫squeda,
dio lugar a la aparici√≥n de la Inteligencia Artificial (IA) y del primer sistema de resoluci√≥n general
de problemas (GPS, General Problem Solver) creado por Herbert Simon y Allen Newell en
1957[1]. Este sistema ten√≠a como objetivo resolver problemas de tipo general, que deb√≠an ser
representados mediante un lenguaje de alto nivel basado en un modelo conceptual, por medio
de un algoritmo de prop√≥sito general. De forma que el sistema de resoluci√≥n era capaz de definir
una secuencia de pasos o acciones que tras su ejecuci√≥n permit√≠an resolver el problema,
partiendo de una representaci√≥n inicial del entorno (estado inicial) hasta una representaci√≥n final
donde una serie de objetivos eran conseguidos (estado final), de forma que el problema era
resuelto. Con el fin describir de manera sencilla el funcionamiento de un sistema general de
resoluci√≥n de problemas, vamos a utilizar uno de los problemas m√°s utilizados por los
investigadores en IA. El 8-Puzzle o puzzle deslizante, mostrado en la Figura 1, es un problema
l√≥gico que consiste en colocar un conjunto de piezas (8 piezas num√©ricas) en un determinado
orden mediante la definici√≥n de una secuencia de movimiento individuales (arriba, abajo,
izquierda y derecha) que se aplican sobre una determinada pieza utilizando la casilla libre que
se denomina casilla blanca.

4Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
Figura 1: Ejemplo de resoluci√≥n del 8-Puzzle
En el ejemplo mostrado en la Figura 1, se presenta una determinada configuraci√≥n inicial del 8-
puzzle que se considera incorrecta y que debe ser modificada mediante la aplicaci√≥n de
movimientos hasta conseguir llegar al estado final, que se denomina estado. Teniendo en cuanta
esta definici√≥n del problema, la soluci√≥n consiste en la secuencia de movimientos que nos
permiten transitar del entado inicial al estado meta. Esta forma de resolver problemas de manera
autom√°tica se denomina Inteligencia Artificial Simb√≥lica[2] y fue el principal paradigma desde
la aparici√≥n del concepto de IA hasta la d√©cada de los 90. La IA Simb√≥lica se basa en el concepto
de razonamiento simb√≥lico que consiste en representar el conocimiento del entorno mediante la
utilizaci√≥n de conceptos b√°sicos denominados s√≠mbolos que deben ser manipulados de forma
independiente mediante el uso de operaciones, reglas, acciones, etc.
Figura 2: Ejemplo de representaci√≥n de simb√≥lica del 8-puzzle
Por ejemplo, si queremos representar el problema de la Figura 2, deberemos definir un s√≠mbolo
para representar las diferentes posiciones del juego, de forma que cada casilla tiene que tener
5
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
una posici√≥n y una pieza. Este s√≠mbolo es una forma abstracta de representar el entorno. Para
ello, introduciremos el s√≠mbolo CASILLA que se representa como un predicado en l√≥gica
proposicional, concepto que fue definido en el Tema 3 de este curso. Este predicado tiene dos
par√°metros: (1) la posici√≥n en la matriz que representa el puzzle; y (2) la pieza que se encuentra
en esa posici√≥n. De forma que, si queremos mover una pieza, tendremos que eliminar dos
s√≠mbolos y crear dos nuevos a continuaci√≥n. Estos s√≠mbolos se corresponder√°n con el s√≠mbolo
que representa la posici√≥n a mover y el que representa la posici√≥n donde se encuentre la pieza
blanca. Teniendo en cuenta todo esto, se pueden definir una serie de caracter√≠sticas comunes a
todos los sistemas de IA simb√≥lica.
‚ñ™
Un modelo conceptual, es decir un conjunto de elementos b√°sicos que permit√≠an
describir de forma general mediante la utilizaci√≥n de s√≠mbolos los diferentes problemas
que pueden ser resueltos por el sistema. De forma general, el modelo conceptual debe
ser capaz de representar el problema, las operaciones, as√≠ como la soluci√≥n que resuelve
el problema.
‚ñ™
Un lenguaje de representaci√≥n de alto nivel que permita describir de forma general
cualquier problema.
‚ñ™
Un algoritmo de prop√≥sito general que permita resolver cualquier problema que sea
representado mediante el lenguaje de alto nivel siguiendo el modelo conceptual descrito.
Este algoritmo deber√° encontrar la soluci√≥n que permite resolver el problema.
Durante el gran apogeo de la IA Simb√≥lica se desarrollaron dos grandes familias de algoritmos
y/o t√©cnicas para la resoluci√≥n autom√°tica de problemas: (1) el Razonamiento Autom√°tico
basado en la construcci√≥n de sistemas expertos que intentan razonar de forma similar a como lo
hacen los humanos y (2) la B√∫squeda basada en la construcci√≥n de algoritmos que realizan una
b√∫squeda en el espacio de estados o soluciones.
2. RAZONAMIENTO AUTOM√ÅTICO
El Razonamiento Autom√°tico puede definirse como el √°rea de la IA que estudia c√≥mo crear
sistemas que sean capaces de resolver problemas que requieren razonamiento de forma similar
a como lo har√≠a un ser humano. Este tipo de sistemas son denominados ‚ÄúSistemas expertos‚Äù [3]
ya que intentan simular el proceso de toma de decisiones de un humano ‚Äúexperto‚Äù en la
resoluci√≥n de tipo espec√≠fico de problema. Por ejemplo, uno de los primeros sistemas expertos
a principios de la d√©cada de los 70 fue Mycin [4]. Este sistema permit√≠a diagnosticar ciertas
¬© Structuralia
6Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
enfermedades infecciosas de la sangre generando como soluci√≥n un posible tratamiento en base
a cierta informaci√≥n personal del paciente (estatura, peso, edad, etc). Este sistema recog√≠a la
informaci√≥n del paciente mediante una serie de preguntas y a continuaci√≥n mediante la aplicaci√≥n
de sistema de inferencia y 500 reglas, que hab√≠an sido dise√±adas por un conjunto de expertos,
era capaz de identificar un conjunto posible de enfermedad y sugerir un tratamiento espec√≠fico
para el paciente. En base a esto podemos decir que los sistemas expertos est√°n formado por un
tres elementos b√°sicos:
‚ñ™
Un modelo conceptual que permita definir todos los elementos b√°sicos del sistema.
Estos elementos de informaci√≥n son utilizados para el proceso de razonamiento, as√≠ como
un conjunto de pruebas (reglas, operaciones, acciones, etc) que permiten al sistema
explicar porque una conjetura es una consecuencia de un conjunto de axiomas e
hip√≥tesis. Todo esta informaci√≥n suelen ser definida por un conjunto de expertos que
tiene un conocimiento muy amplio del problema y de la forma de solucionarlo.
‚ñ™
Un lenguaje de alto nivel que permita describir de forma sencilla los diferentes elementos
del modelo conceptual. Com√∫nmente este lenguaje es l√≥gica proposicional de primer
orden (descrita en el tema 3 de este curso), aunque es posible utilizar l√≥gicas de orden
superior o incluso otro tipo de lenguaje basado en otros formalismos matem√°ticos. En
este tema s√≥lo vamos a tratar con representaciones basadas en l√≥gica de primer orden.
‚ñ™
Un mecanismo de inferencia (algoritmo) que permita resolver el problema en base al
modelo conceptual definido.
Una vez que han sido definidos y/o seleccionados todos estos elementos es posible construir un
sistema experto espec√≠fico para resolver un determinado tipo de problemas. Dependiendo de
c√≥mo sea definida este tipo de informaci√≥n y los algoritmos que son utilizados para resolver el
problema es posible definir diferentes modelos de razonamiento:
‚ñ™Basado en reglas l√≥gicas.
‚ñ™Basado en casos.
‚ñ™Basado en Inferencia bayesiana.
‚ñ™Basado en l√≥gica borrosa o difusa.
En este tema s√≥lo vamos a tratar de forma detallada los modelos de razonamiento m√°s utilizados
o conocidos: Razonamiento basado en reglas, Razonamiento basado en casos y el
Razonamiento basado en l√≥gica borrosa.
7
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
2.1 Razonamiento basado en reglas
Uno de los sistemas de razonamiento autom√°tico m√°s extendido es el Razonamiento basado
en reglas [6], tambi√©n denominado sistemas de producci√≥n, el cual es una t√©cnica de resoluci√≥n
autom√°tica de problemas basada en la utilizaci√≥n encadena de reglas en un proceso de
inferencia. Este conjunto de reglas van siendo activadas a medida que sus condiciones son
evaluadas de forma positiva dando lugar a nuevos hechos que permitan la aplicaci√≥n de nuevas
reglas. Este proceso deductivo se aplicar√° hasta que no exista ninguna regla que pueda ser
aplicada, bien porque se ha resuelto el problema o porque no es posible resolverlo. Este tipo de
t√©cnicas est√°n basadas en la utilizaci√≥n de tres elementos b√°sicos que permiten modelar la
informaci√≥n que describe el problema y definir las diferentes reglas que ser√°n utilizadas para
realizar el proceso de razonamiento:
‚ñ™
Una base de hechos acerca del mundo (entorno) que describen el conocimiento
espec√≠fico que el sistema puede manipular acerca del mundo. Donde un hecho puede
definirse como una pieza b√°sica de informaci√≥n utilizada para describir una caracter√≠stica
del mundo que es cierta (evidencia). En el caso de l√≥gica de primer orden el mundo est√°
constituido de objetos y predicados que definen las propiedades de dichos objetos. Estos
hechos son utilizados para definir el estado del mundo y pueden ser creados y destruido
durante el proceso de razonamiento con el fin de obtener conclusiones l√≥gicas.
ObjetoValores
TarjetaVerificada, no_verificada
FechaExpirada, no_verificada
PINcorrecto, incorrecto
IntentosExcedidos, no_excedidos
L√≠miteExcedido, no_excedido
PagoAutorizado, no_autorizado
Tabla 1 - Ejemplo de objetos y predicados definidos para modelar el funcionamiento de un cajero autom√°tico
mediante la utilizaci√≥n de l√≥gica proposicional

8Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
En la Tabla 1 se presenta el ejemplo de los objetos y predicados para modelar el
funcionamiento de un cajero autom√°tico. En este caso tenemos 6 objetos diferentes y dos
valores o hechos para cada uno de los objetos. Por ejemplo una tarjeta puede est√°s o no
verificada. Como se puede observar la definici√≥n de los hechos es de forma dual es decir
la existencia de un predicado implica la inexistencia del otro.
‚ñ™
Una base de conocimiento que incluye un conjunto de reglas definidas de forma manual
por al menos un experto que permiten extraer conclusiones de los hechos que definen el
problema. Es decir, las reglas son el mecanismo de razonamiento que permite dado una
situaci√≥n inicial del problema llegar a una situaci√≥n final. Estas reglas son definidas como
proposiciones l√≥gicas que relacionan dos o m√°s objetos de la base de hechos a trav√©s
de una serie de premisas (antecedentes) que dan lugar a una serie de conclusiones
(consecuentes). Donde los antecedentes se corresponden con un conjunto de predicados
conectados mediante operadores l√≥gicos y los consecuentes son las diferentes
conclusiones que se obtienes al aplicar una regla. En base a esto, la estructura b√°sica de
una regla ser√≠a:
SI antecedente ENTONCES consequente1 SINO consequente2
En base a los objetos y valores descritos en la Tabla 1 se podr√≠an definir algunas reglas
como las mostradas a continuaci√≥n:
SI Tarjeta = no_verificada ENTONCES Pago = no_autorizado
SI Fecha = expirada ENTONCES Pago = no_autorizado
SI PIN = incorrecto ENTONCES Pago = no_autorizado
‚ñ™
Un motor de inferencia es el algoritmo mediante el cual se produce el proceso de
razonamiento a partir de la informaci√≥n almacenada en la hechos es capaz de inferir
conclusiones y hechos mediante la utilizaci√≥n de las reglas almacenadas en la base de
conocimiento. Es decir, el motor de inferencia va seleccionado reglas de la base de
conocimiento en base a la informaci√≥n almacenada en la base de hechos de forma que
9
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
cuando el antecedente de una regla es cierto esta se aplica generando un conjunto de
hechos y/o conclusiones que son a√±adidos a la base de hecho como resultado de la
aplicaci√≥n de la regla.
En base a estos tres elementos el sistema es capaz de razonar generando conclusiones que
permiten al sistema de razonamiento resolver un problema que es configurado en base a la
estructura de hechos y reglas utilizados para definir el problema. El proceso de resoluci√≥n que
se produce en el motor de inferencia es guiado mediante la utilizaci√≥n de una serie de reglas de
inferencia, las cuales son definidas de modo general, que son aplicadas en base a una
determinada estrategia.
2.1.1. Reglas para la generaci√≥n de pruebas deductivas
Para poder inferir conclusiones durante un proceso de razonamiento, es necesario definir una
serie de reglas especificas al problema las cuales normalmente est√° basadas en alguna reglas
de tipo general: El modus ponens y el modus tollens.
Modus Ponens
El modus ponens, tambi√©n denominada regla de separaci√≥n, es la regla de inferencia en l√≥gica
proposicional m√°s utilizada debido a que permite obtener una conclusi√≥n simple en base a una
premisa o antecedente. Datos dos proposiciones P y Q donde P es el antecedente y Q es el
consecuente, el modus ponens puede enunciar de la siguiente manera:
‚ÄúSi P implica Q; y si P es verdad, entonces Q tambi√©n es verdad‚Äù
(ùëÉ ‚Üí ùëÑ) ‚àß ùëÉ ‚üπ ùëÑ
De manera formal podemos definir que la regla del Modus Ponens como una regla formada por
dos antecedentes que son la implicaci√≥n de Q en base a P y la certeza de P. Este silogismo se
suele representar de la siguiente manera:
ùëÉ‚ÜíùëÑ
ùëÉ
ùëÑ

10Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
Modus Tollens
El modus tollendo ponens, tambi√©n denominada regla de eliminaci√≥n de la disyunci√≥n, es una
regla de inferencia de l√≥gica proposicional. Dados dos proposiciones P y Q donde P es el
antecedente y Q es el consecuente, el modus tollendo ponens se puede enunciar de la siguiente
manera:
‚ÄúSi P o Q es verdad; y P es falso, entonces Q tambi√©n es verdad‚Äù
(ùëÉ ‚Üí ùëÑ) ‚àß ¬¨ùëÑ ‚üπ ¬¨ùëÉ
El silogismo disyuntivo establece que, si se nos indica que al menos una de las dos proposiciones
es verdadera; y tambi√©n se indica que no es la primera proposici√≥n la que es verdadera; se puede
inferir que debe ser la √∫ltima la que es verdadera. Este silogismo se suele representar de la
siguiente manera:
ùëÉ‚ÜíùëÑ
¬¨ùëÑ
¬¨ùëÉ
2.1.2. Encadenamiento de reglas
Para poder obtener una soluci√≥n a un determinado problema los sistemas de razonamiento
basados en reglas realizan un proceso de selecci√≥n de reglas en base a la informaci√≥n disponible
en la base de hecho. Este proceso de selecci√≥n consiste en un encadenamiento de reglas debido
a que las reglas son encadenadas en base a las relaciones entre las premisas (antecedentes) y
las conclusiones (consecuentes) de ciertas reglas. Este proceso de encadenamiento va
generando nuevos hechos hasta que no es posible seleccionar m√°s reglas o se alcanzan todas
las conclusiones que resuelven el problema. Dependiendo de c√≥mo se utiliza la informaci√≥n de
la base de hechos se pueden diferenciar dos tipos de algoritmos de encadenamiento: Hacia
delante y hacia atr√°s. La informaci√≥n puede ser utilizada para realizar b√∫squeda hacia delante
comenzando por los hechos actuales o hacia atr√°s buscando desde los objetivos del problema
hacia atr√°s.
Encadenamiento de reglas hacia delante
El algoritmo de encadenamiento de reglas hacia delante o dirigido por datos consiste en generar
una secuencia de reglas encadenadas que comienzan a seleccionar reglas desde un conjunto
de hechos conocidos que son considerados con el estado inicial desde los que se empieza a
11
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
resolver el problema. Este algoritmo va incluyendo nuevos hechos en la base de hechos seg√∫n
se van seleccionando las diferentes reglas partiendo de una base de hechos que incluye la
informaci√≥n inicial del problema (estado inicial). Este tipo de algoritmo es muy √∫til para la
resoluci√≥n de problemas de planificaci√≥n, configuraci√≥n y dise√±o autom√°tico. Los motores de
inferencia basados en este tipo de algoritmos est√°n basados en un proceso secuencial
compuesto por cuatro fases:
1. Inicializaci√≥n: Este proceso s√≥lo se ejecuta al inicio y consiste en inicializar las diferentes
estructuras de datos: (1) La agenda que contiene todos los hechos activos de la base de
hechos; y (2) la lista de reglas activas que contiene aquellas reglas que son disparadas o
identificadas durante el proceso de identificaci√≥n. La agenda hace las veces de estructura
de control de algoritmo manteniendo informaci√≥n del proceso de ejecuci√≥n que es
relevante para la identificaci√≥n de reglas.
2. Identificaci√≥n (Matching): El proceso de identificaci√≥n se encarga de analizar todas las
reglas de la base de conocimiento identificando aquellas reglas relevantes en base a la
informaci√≥n almacenada en la base de hechos. Es decir, identifica las reglas que se
disparan en base a la base de hechos disponible. La relevancia de la reglas se basa en
diferentes factores: satisfabilidad, referencias con el √∫ltimo conocimiento derivado, nuevo
conocimiento para la base de hechos, etc.
3. Resoluci√≥n de conflictos: El proceso de resoluci√≥n de conflictos consiste en seleccionar
aquella regla m√°s importante de entre todas la seleccionados en el proceso de
identificaci√≥n. El mecanismo m√°s utilizado para la resoluci√≥n de conflictos se basa en el
establecimiento de prioridades entre las reglas de forma que cuando se produzca un
conflicto entre varias reglas, se resolver√° hacia la de mayor prioridad.
4. Ejecuci√≥n: El proceso de resoluci√≥n consiste en ejecutar la regla resultante de la
resoluci√≥n de conflictos. El proceso de ejecuci√≥n de una regla consiste en a√±adir los
nuevos hechos a la base de hechos, lo que conlleva la activaci√≥n de nuevas reglas que
podr√°n ser seleccionadas en la siguiente iteraci√≥n.
5. Reinicio (Reset): El proceso de reinicio es una fase opcional del algoritmo de
encadenamiento y realiza una eliminaci√≥n de las reglas que fueron consideras relevantes
en la fase anterior con el fin de disminuir la aparici√≥n de conflictos. Una vez producido el
proceso de eliminaci√≥n se vuelve a la fase 2.

12Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
Encadenamiento de reglas hacia atr√°s
El algoritmo de encadenamiento de reglas hacia atr√°s o dirigido por objetivos consiste en generar
una secuencia de reglas encadenadas que comienzan en la conclusi√≥n deseada hasta alcanzar
un estado en el cual todos los hechos se corresponde con los iniciales. Este algoritmo utiliza una
pila de objetivos (metas) que se utiliza como estructura de control para guiar el proceso de
activaci√≥n de las diferentes reglas. Este algoritmo comienza con una base de hechos vac√≠a en la
cual se van incluyendo nuevas hechos seg√∫n se van disparando las diferentes reglas. Este tipo
de algoritmo es muy √∫til para la resoluci√≥n de problemas de diagn√≥stico. Los motores de
inferencia basados en este tipo de algoritmos est√°n basados en un proceso secuencial
compuesto por tres fases o procesos:
1. Inicializaci√≥n: Este proceso s√≥lo se ejecuta al inicio y consiste en inicializar las diferentes
estructuras de datos: (1) La agenda que se encuentra generalmente vac√≠a; (2) la lista de
reglas activas que contiene aquellas reglas que son disparadas o identificadas durante el
proceso de identificaci√≥n; y (3) la pila de objetivos que se inicializa con todos los objetivos
iniciales del problema.
2. Selecci√≥n de objetivos: El proceso de selecci√≥n de objetivos consiste en seleccionar el
objetivo que se encuentra en la cima de la pila y identifican todas las reglas que son
capaces de satisfacer ese objetivos.
3. An√°lisis de premisas: El proceso de an√°lisis realiza un an√°lisis de todas las reglas
seleccionadas en la fase anterior mediante el siguiente proceso:
‚ñ™
Si todas las premisas (antecedentes) de una regla se pueden satisfacer, se ejecuta la
regla deriv√°ndose sus conclusiones y se desapila el objetivo de la cima de la pila
volviendo a continuaci√≥n al paso 2.
‚ñ™
Si alguna premisa (antecedentes) de una regla es desconocida pero existe al menos
otra regla que la fije (es la conclusi√≥n de otra regla), se ejecuta la regla deriv√°ndose
sus conclusiones y se apila la premisa desconocida como nuevo objetivo volviendo
al paso 2.
‚ñ™
Si alguna premisa (antecedentes) de una regla es desconocida y no existe ninguna
regla que la fije se pregunta al usuario incluy√©ndose el valor introducido en la base de
hechos, si la premisa introducida por el usuario satisface la regla, se pasa a la
siguiente premisa y en caso contrario se descarta la reglas volviendo a continuaci√≥n
al paso 2.
13
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
4. Purgado: El proceso de purgado es opcional y s√≥lo se ejecuta cuando ninguna de las
reglas del paso 2 es verdadera de forma que el objetivo no puede ser satisfecho.
Entonces el objetivo es desapilado de la pila de objetivos y etiquetado como desconocido
en la base de hechos.
2.2 Razonamiento basado en casos
El Razonamiento basado en casos (CBR, en sus siglas en ingl√©s) [6] es una t√©cnica de
resoluci√≥n autom√°tica de problemas basada en la hip√≥tesis de que problemas similares deben
tener soluciones parecidas. Es decir, este tipo de t√©cnicas utiliza un sistema de memoria,
denominada base de casos, para almacenar informaci√≥n acerca de cada problema resuelto
(experiencias) con el fin de que estas ‚Äúexperiencias pasadas‚Äù puedan ser utilizadas como gu√≠a
para resolver problemas similares de mayor complejidad. Este tipo de t√©cnicas puede verse como
un proceso iterativo de aprendizaje y reutilizaci√≥n de casos.
2.2.1. Representaci√≥n de la informaci√≥n en casos
En este tipo de t√©cnicas, la informaci√≥n es representada mediante la utilizaci√≥n de casos o
unidades de conocimiento. Un caso es una unidad de informaci√≥n previo que es almacenado en
un sistema de memoria con el fin de poder ser utilizado por otros problemas con el fin de razonar
en base a ellos. Es decir estos casos se pueden considerar como experiencias pasadas que
pueden ser utilizadas para facilitar el proceso de razonamiento en problemas de mayor
complejidad. De forma general un caso se puede definir como un conjunto de tres elementos:
‚ñ™
Representaci√≥n del problema: Es la informaci√≥n que representa el problema que se
quer√≠a resolver. Es necesario que est√° informaci√≥n sea modelada de manera gen√©rica
debido a que tiene que ser sencillo buscar similitudes entre la informaci√≥n almacenada
en la base de casos y el problema que est√° intentando resolver.
‚ñ™
Soluci√≥n: Es la soluci√≥n obtenida al resolver el problema o el conjunto de acciones o
pasos que se han realizado para obtener dicha soluci√≥n. Dependiendo de c√≥mo sea
representada la soluci√≥n al problema puede que la soluci√≥n y los pasos sean exactamente
lo mismo, como por ejemplo ocurre en los problemas de b√∫squeda, los cuales son
descritos posteriormente en este documento.

14Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
‚ñ™
Conjunto de efectos: Es la representaci√≥n del entorno una vez que se ha resuelto el
problema. Este tipo de informaci√≥n es probablemente la m√°s importante en las t√©cnicas
de razonamiento basado en casos ya que permite identificar problemas similares o
problemas que pueden ser identificados como un subproblema de un problema mucho
m√°s complejo.
Este tipo de representaci√≥n permite almacenar informaci√≥n de manera gen√©rica produciendo un
sistema de resoluci√≥n independiente del domino. Por ejemplo se podr√≠a representar un problema
binario de clasificaci√≥n donde la representaci√≥n del problema es el conjunto de variables de tipo
atributo-valor, la soluci√≥n es la clase en la que ha sido clasificado el ejemplo y los efectos podr√≠as
consistir en almacenar √∫nicamente aquellos casos que pertenecen s√≥lo a un tipo de clase.
Tambi√©n ser√≠a posible representar un problema de b√∫squeda de forma similar, donde la
representaci√≥n del problema es el estado inicial, la soluci√≥n es la secuencia de operadores que
generar un estado meta y el conjunto de efectos se corresponder√≠a con la informaci√≥n que
representa ese estado meta. Dependiendo de la forma en la que se modelan los casos se pueden
distinguir dos tipos diferentes de sistemas de razonamiento basado en casos [7]:
‚ñ™
Clasificaci√≥n: Este tipo de sistemas de razonamiento basado en casos se aplica a
problemas donde la soluci√≥n consiste en identificar una determinada clase (enfermedad,
modelo, etc.) en base a un conjunto de valores de entrada. Este tipo de sistemas de
razonamiento es muy √∫til para problema con informaci√≥n incompleta, como por ejemplo,
los sistemas de diagn√≥stico, predicci√≥n, control de procesos, etc.
‚ñ™
S√≠ntesis: Este tipo de sistemas de razonamiento basado en casos se aplica a problemas
donde la soluci√≥n debe ser construida en base a un conjunto de casos que deben ser
combinados y adaptados. Este tipo de sistemas de razonamiento es muy √∫til para
problemas de elevada complejidad, como por ejemplo, los sistemas de configuraci√≥n,
planificaci√≥n autom√°tica o dise√±o de procesos.
2.2.2. Modo de razonamiento
El proceso de razonamiento basado en casos puede describirse como un ciclo continuo de
aprendizaje en el cual se va mejorando el proceso de razonamiento en base a como se aumenta
la experiencia del sistema. De forma general el proceso de funcionamiento de estos sistemas
consta de 4 procesos, como se muestra en la Figura 3.
15
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
Figura 3: Proceso de funcionamiento del razonamiento basado en casos
Recuperaci√≥n
El proceso de recuperaci√≥n consiste en la extracci√≥n de informaci√≥n de la base de casos con
respecto a su similitud al estado actual del problema. Para ello es necesario definir un medida
de similitud que permita realizar consultas a la base de casos. El proceso de identificaci√≥n de
casos similares suele estar formado por cuatro etapas con el fin de minimizar al m√°ximo el
n√∫mero de posibles casos a utilizar:
1. Identificaci√≥n e caracter√≠sticas: Los problemas son almacenados con un n√∫mero muy
elevado de caracter√≠sticas, por lo que inicialmente en necesario identificar un conjunto de
caracter√≠sticas que permitir√°n seleccionar aquellos casos similares entre s√≠. Esta fase
identifica aquellas caracter√≠sticas que definen de la manera m√°s completa el caso que se
est√° analizando.
2. Comparaci√≥n: Una vez identificadas aquellas caracter√≠sticas es necesarios realizar un
proceso de ‚Äúmatching‚Äù con el fin de identificar los casos similares. Dependiendo de c√≥mo
este construida la base de casos este proceso de comparaci√≥n se pueden realizar sobre
toda la base de casos o sobre un subconjunto delimitado por los √≠ndices. Esta fase realiza
un proceso de selecci√≥n con el fin de seleccionar aquellos casos similares.
3. Ranking: Una vez identificados los casos similares, es necesario definir alg√∫n tipo de
medida que permita ordenar los casos. Para ello es necesario utilizar un funci√≥n de
similitud que genera un valor en base a la distancia entre dos casos. Cuanto m√°s similares
sean dos casos mayor ser√° el valor devuelto por esta funci√≥n. Esta fase ordena los casos
similares en fase al resultado de la funci√≥n de similitud.

16Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
4. Selecci√≥n: Esta es la √∫ltima fase del proceso de recuperaci√≥n y consiste en seleccionar
los n casos con mayor similitud dependiendo de c√≥mo se vayan a realizar las siguientes
etapas del proceso de razonamiento. Lo m√°s com√∫n es s√≥lo seleccionar un √∫nico caso.
Reutilizaci√≥n
El proceso de reutilizaci√≥n consisten en utilizar la informaci√≥n que ha sido seleccionada en la
fase previa con el fin de resolver el problema. La fase de reutilizaci√≥n ser√° diferente dependiendo
del tipo de problema de razonamiento que se est√© resolviendo (clasificaci√≥n o s√≠ntesis). En el
caso de problemas de clasificaci√≥n se seleccionar√° directamente el caso m√°s similar; y en el
caso de problemas de s√≠ntesis se deber√° realizar un proceso de adaptaci√≥n de los casos
seleccionados en la fase de recuperaci√≥n que puede realizarse de dos maneras diferentes:
1. Transformaci√≥n: El proceso de transformaci√≥n consiste en cambiar estructuralmente el
caso seleccionado conservando aquellas partes que son similares y modificando aquellas
que no se adaptan. Este proceso de transformaci√≥n puede realizarse de diferentes formas
(sustituci√≥n, reglas de transformaci√≥n, ajuste de par√°metros, etc).
2. Derivaci√≥n: El proceso de derivaci√≥n consiste en generaci√≥n una nueva soluci√≥n
mediante la utilizaci√≥n de las mismas operaciones (acciones, reglas, inferencias, etc.)
usadas para resolver el problema descrito en el caso seleccionado. Es decir, este proceso
intenta transferir por analog√≠a el proceso de razonamiento.
Normalmente estos dos procesos se utilizan de forma independiente, aunque existen algunos
enfoques h√≠bridos que utilizan ambos procesos. Realizan una re-instanciaci√≥n del caso mediante
un proceso de transformaci√≥n y luego se utiliza un proceso de derivaci√≥n.
Revisi√≥n
El proceso de revisi√≥n analiza la soluci√≥n generada con el fin de comprobar si la soluci√≥n es
correcta y puede resolver de forma correcta el problema.
Retenci√≥n
El proceso de retenci√≥n es la fase final del razonamiento basado en casos y probablemente uno
de los m√°s importantes ya que se encarga del mantenimiento de la base de casos mediante la
informaci√≥n extra√≠da por el nuevo problema resuelto. Dependiendo de c√≥mo este construido el
sistema de razonamiento se pueden definir 4 fases en el proceso de retenci√≥n:
17
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
1. Evaluaci√≥n: El proceso de evaluaci√≥n analiza el nuevo problema e identifica si es posible
incluir nuevos casos en la base de casos.
2. Combinaci√≥n: El proceso de combinaci√≥n realiza una uni√≥n de uno o m√°s casos similares
mediante alg√∫n tipo de t√©cnica de generalizaci√≥n. El proceso de mezcla suele ser definido
en la fase de evaluaci√≥n y normalmente depende la similitud de los casos y del ratio de
crecimiento que se le permita a la base de casos.
3. Indexaci√≥n: El proceso de indexaci√≥n inserta el nuevo caso en la base de casos.
4. Eliminaci√≥n: El proceso de eliminaci√≥n realiza ciertas acciones de mantenimiento
determinando si alguno de los casos almacenados ya no es v√°lido.
2.3 Razonamiento borroso o difuso
Los dos modelos de razonamiento descritos previamente se basan en el concepto de l√≥gica
cl√°sica o bivaluada donde la informaci√≥n del mundo es definida mediante proposiciones binarias,
normalmente predicados, cuya existencia implica que la proposici√≥n es verdadera y sino implica
que es falsa. Pero muchas veces la informaci√≥n del mundo real no puede ser modelada mediante
proposiciones bivaluadas debido a que no es posible definir muchos de los conceptos del entorno
en base a una verdad absoluta o una completa falsedad, por lo que es necesario incluir m√°s
valores para representar una proposici√≥n extendiendo la l√≥gica cl√°sica a un tipo de l√≥gica
superior denominada multivaluada. Debido a esta necesidad, en 1965 se defini√≥ el concepto de
l√≥gica difusa [8] que es un tipo superior a la l√≥gica de primer orden (cl√°sica) que permite definir
infinitos valores reales comprendidos entre 0 y 1 para una proposici√≥n. Es decir, este tipo de
l√≥gica permite la utilizaci√≥n de premisas imprecisas para modelar el conocimiento mediante un
grupo de conjuntos interrelacionados entre s√≠.
2.3.1. Conjuntos borrosos
En la l√≥gica cl√°sica la informaci√≥n es representada mediante conjunto cl√°sicos (crips) donde se
asigna el valor 0 o 1 a cada elemento de para indicar si pertenece o no al conjunto. Pero, este
concepto de pertenencia se puede generalizar de forma que los valores asignados a los
elementos del conjunto caigan en un determinado rango que permita indicar el grado de
pertenencia de los elementos al conjunto [9]. Esta funci√≥n se denomina funci√≥n de pertenencia
ŒºA(x) y el conjunto definido mediante ella se denominada conjunto borroso A. Esta funci√≥n
devolver√° un valor entre 0 y 1 para el elemento x que indicar√° el grado de pertenencia a dicho
conjunto. La suma de los grados de pertenencia a todos los conjuntos borrosos relacionados
¬© Structuralia
18Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
debe ser siempre 1. La Figura 4 presenta un conjunto borroso para la definici√≥n de la
temperatura del entorno formado por 5 posibles conjuntos representados por un variable
ling√º√≠stica (Helado, Fr√≠o, Tibio, Templado y C√°lido) cada uno de los cuales tienen una funci√≥n de
pertenencia acotada donde la altura representa en la figura representa el grado de pertenencia,
siendo los valores posibles entre 0 y 1. Es decir, existen elementos que pueden pertenecer a
varios conjuntos a la vez con un grado diferente de pertenencia. Por ejemplo un elemento con
un valor de -7 grados puede pertenecer al conjunto Helado y al conjunto Frio con diferentes
grados de pertenencia, donde la suma de ambos valores debe ser 1.
Figura 4: Ejemplo de un conjunto borroso para la definici√≥n del temperatura en grados cent√≠grados.
La gran ventaja de los conjuntos borrosos es que son capaces de modelar la informaci√≥n del
entorno de forma mucho m√°s precisa ya que permite representar la informaci√≥n mediante una
serie infinita no numerable de conjuntos cl√°sicos. Esta forma de representar el conocimiento
permite representar concepto subjetivos que hacen m√°s f√°cil representar el conocimiento
humano.
2.3.2. Modo de razonamiento aproximado
El razonamiento aproximado[8] es una t√©cnica de resoluci√≥n autom√°tica de problemas basada
en la obtenci√≥n de conclusiones a partir de informaci√≥n incompleta o con cierto grado de
incertidumbre que es modelada mediante la utilizaci√≥n de conjuntos borrosos. Los diferentes
sistema basados en razonamiento aproximado funcionan de forma similar a los sistemas
basados en reglas con la salvedad de que las reglas de la base de conocimiento pueden utilizar
conjuntos borrosos para representar los antecedentes y consecuentes. En este tipo de sistemas
es posible inferir conclusiones en situaciones en las cuales aunque los antecedentes no
verifiquen de forma plena la regla. Por ejemplo, en el caso de que estemos creando reglas en
19
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
las que intervenga como antecedente el conjunto borroso definido en la Figura con un valor de -
6 grados cent√≠grados. De forma que el resultado para las funciones de pertenencia ser√≠a
ŒºHelado(-6) = 0,58 y ŒºFrio(-6) = 0,42. Dados estos valores se podr√≠an disparar reglas que
esperasen el valor Helado y Frio. Dependiendo de c√≥mo se modelen este tipo de elementos
podemos definir dos tipos de reglas borrosas:
‚ñ™
Reglas de tipo Mamdani: Son reglas borrosas puras, es decir tienen un antecendente
definido mediante un conjunto borroso y una consecuente definido como un conjunto
borroso.
SI x es Helado ENTONCES y es Congelaci√≥n severa
SI x es Frio ENTONCES y es Congelaci√≥n lebe
‚ñ™
Reglas de tipo Sugeno: Son reglas borrosas parciales, es decir el antecedente es
definido mediante un conjunto borroso y el consecuente son valores num√©ricos lo que
implica que que no es necesaria una fase de desborrosificaci√≥n.
SI x es Helado ENTONCES y es F(x)
Los motores de inferencia borrosos (FIS, es sus siglas en ingl√©s) est√°n basados en un proceso
secuencial compuesto por cinco fases o procesos: (1) borrosificaci√≥n de hechos; (2) aplicaci√≥n
del operador borroso en el antecedente; (3) implicaci√≥n del antecedente al consecuente; (4) la
agregaci√≥n de los consecuentes a trav√©s de las normas; y (5) la desborrosificaci√≥n (opcional) de
hechos. Estas etapas son similares a las definidas para un sistema no borroso donde las fases
3, 4 y 5 se podr√≠an corresponder con las fases de identificaci√≥n, resoluci√≥n de conflictos y
ejecuci√≥n. Las √∫nicas fases diferentes son aquellas que permiten transformar la informaci√≥n del
entorno en conjunto borrosos y viceversas, las cuales son descritas a continuaci√≥n.
Borrosificador
El borrosificador es un sistema que transforma la informaci√≥n no borrosa almacenada en la base
de hechos a sus correspondientes conjuntos borrosos, es decir, se calcula el valor de pertenencia
a cada conjunto con el fin de poder aplicar las diferentes reglas. Existen dos tipos de estrategias
de borrosificaci√≥n:

20Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
‚ñ™
Singleton. Es el m√©todo de borrosificaci√≥n m√°s utilizado, principalmente en sistemas de
control, y consiste en considerar los propios valores discretos con conjuntos borrosos.
‚ñ™
No singleton. En este m√©todo de borrosificacion se utiliza una funci√≥n exponencial para
transformar los valores.
El borrosificador transforma la informaci√≥n de la base de hechos para poder disparar las
diferentes reglas en las siguientes fases del proceso.
Desborrosificador
El desborrosificador es un sistema que transforma los conjuntos borrosos en valores no borrosos
y que son almacenados en la base de hechos. Este proceso de desborrosificaci√≥n se puede
realizar por diferentes m√©todos:
‚ñ™Desborrosificador por m√°ximo (Mamdani).
‚ñ™Desborrosificador por media de centros (Mamdani).
‚ñ™Desborrosificador por centro de √°rea (Mamdani).
‚ñ™Desborrosificador por media ponderada (Sujeno). En este caso no se aplica realmente
un proceso de borrosificaci√≥n sino que la propia regla genera el valor num√©rico.
2.4 Otros tipos de razonamiento
Adem√°s de los tres sistemas de razonamiento autom√°tico descritos en este documento existe
otras formas de razonamiento, como por ejemplo: (1) Los sistemas de razonamiento basados en
inferencia bayesiana que guardan ciertas similitudes con los sistema de razonamiento borroso;
(2) Los sistemas de razonamiento basados en l√≥gica temporal lineal que incluyen el concepto
de tiempo en el proceso de razonamiento; o (3) Los sistemas de razonamiento anal√≥gico que
intentan razonar mediante analog√≠as sobre las premisas de las reglas.
3. B√öSQUEDA
La B√∫squeda puede ser definida como el conjunto de algoritmos utilizados para resolver
problemas mediante la b√∫squeda en un espacio de estados por medio de la aplicaci√≥n de un
conjunto de operaciones (acciones). Esta familia de t√©cnicas o algoritmos se basa en encontrar
una secuencia de acciones, que puede no ser la √∫nica, que nos permita transitar desde un estado
inicial hasta una estado meta. En la Figura 5 se presenta un ejemplo de una posible soluci√≥n
21
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
generada por un algoritmo de b√∫squeda, que consiste en una secuencia de acciones que
modifican el estado inicial para ‚Äútransformarlo‚Äù en el estado final.
Figura 5: Representaci√≥n de la soluci√≥n a un proceso de B√∫squeda
Actualmente existen diferentes tipo de familias de algoritmos de b√∫squeda que se diferencian
entre s√≠ en como la informaci√≥n que representa el entorno es definida y utilizada para conseguir
encontrar una soluci√≥n. En base a estos criterios podemos diferenciar entre diferentes tipo de
t√©cnica de b√∫squeda:
‚ñ™B√∫squeda no informada.
‚ñ™B√∫squeda informada.
‚ñ™B√∫squeda local.
‚ñ™B√∫squeda en tiempo real.
‚ñ™B√∫squeda con contrincantes .
3.1 Conceptos b√°sicos
Antes de comenzar a describir cada uno de los diferentes algoritmos de b√∫squeda es necesario
describir una serie de conceptos b√°sicos comunes a cada uno de las diferentes familias de
algoritmos de b√∫squeda:
‚ñ™
Instancia: Las instancias son las entidades b√°sicas de informaci√≥n que describen el
problema. Estos est√°n a su vez compuestas por elementos at√≥micos que describen los
elementos b√°sicos del problema de forma m√°s detallada. Es decir, una instancia es un
conjunto finito de elementos at√≥micos. Las instancias pueden ser utilizadas para definir
diferentes facetas del problema, las dos facetas del problemas que son
o
Estado: Las instancias son modeladas como estados, que representan un instante
especifico del entorno, al cual se puede llegar tras la aplicaci√≥n de un operador
que genera una variaci√≥n en los elementos at√≥micos que componen el estado.
¬© Structuralia
22Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
Los estados suelen varias su tama√±o tras la aplicaciones de los operadores, ya
que estos a√±aden o eliminan elementos.
o
Soluci√≥n: Las instancias son modeladas como soluciones al problema que se
quiere resolver, cada una de estas soluciones puede ser definida mediante la
aplicaci√≥n de una operaci√≥n que genera variaciones en la instancia. Un problema
puede tener un conjunto de posibles soluciones, cada una de las cuales puede
ser clasificada en base a alg√∫n tipo de concepto de calidad, que nos permita
comparar la calidad de dos posibles soluciones. Las soluciones normalmente
suelen tener siempre el mismo tama√±o, ya que sus operadores s√≥lo modifican el
valor de los elementos at√≥micos que componen la soluci√≥n, aunque existen
t√©cnicas que permiten variar la estructura de la soluci√≥n.
‚ñ™
Espacio de instancias: El espacio de instancias se corresponde con el conjunto finito de
todas las posibles instancias del problema. Los algoritmos de b√∫squeda de pueden dividir
en dos grandes familias dependiendo de que tipo de instancias que se utilicen para
modelar el problema:
o
B√∫squeda en el espacio de estados: Consiste es buscar una soluci√≥n en el
espacio de estados, donde la soluci√≥n se corresponde con una secuencia de
acciones que modifican la estructura del estado. Comenzando en un estado inicial
hasta encontrar un estado meta. El espacio de estado se modela normalmente
como un grafo expl√≠cito donde los estados son los nodos y los operadores son las
arcos que conectan los nodos.
o
B√∫squeda en el espacio de soluciones: Consiste en buscar una soluci√≥n en el
espacio de estados, donde la instancia representa una soluci√≥n problema que
debe ser mejorara en base a alg√∫n objetivo.
‚ñ™
Operadores: Los operadores son cada una de las operaciones b√°sicas que pueden
aplicarse sobre el espacio de instancias para generar nuevas instancias. Para los
algoritmos de b√∫squeda en espacio de estados pueden ser denominados como acciones,
ya que son acciones que cambian el entorno.
‚ñ™
Espacio de operadores: El espacio de operadores se corresponde con el conjunto finito
de todos los posibles operadores que pueden aplicarse sobre cada una de las instancias
con el fin de generar nuevas instancias.
23
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
‚ñ™
Algoritmo: El algoritmo se corresponde con una t√©cnica de resoluci√≥n mediante la cual se
van generando las diferentes instancias hasta encontrar una de las posibles soluciones
al problema.
3.2 B√∫squeda no informada
La b√∫squeda ciega [10] o no informada es un tipo de b√∫squeda en el espacio de estados donde
no se utiliza ning√∫n tipo de informaci√≥n del problema para resolverlo. Es decir se utilizan
algoritmos de forma para el recorrido de √°rboles de b√∫squeda. Debido a que el grafo que
representa el espacio de estados se puede transformar en un √°rbol si el proceso de b√∫squeda
comienza en un determinado estado denominado estado inicial. Este tipo de b√∫squeda se basa
en la aplicaci√≥n de estrategias sistem√°ticas para la exploraci√≥n del espacio de b√∫squeda, es
decir, se aplica una estrategia fija para definir como los diferentes nodos (estados) del √°rbol son
visitados. El proceso de exploraci√≥n de √°rbol de b√∫squeda se basa en dos procesos b√°sicos:
‚ñ™
Generaci√≥n: Este proceso se corresponde con la generaci√≥n de un estado tras la
aplicaci√≥n de un operador mediante la inserci√≥n y/o eliminaci√≥n de ciertos elementos
at√≥micos.
‚ñ™
Expansi√≥n: Este proceso se corresponde con la expansi√≥n de un estado generado
previamente. Es decir, consiste en la aplicaci√≥n de todos los posible operadores
aplicables sobre el estado, de forma que se genere un conjunto de estados igual al
n√∫mero de operadores aplicables. Los estados generados por el proceso de expansi√≥n
se denominan sucesores (hijos), ya que son los estados generados a partir de un estado
que es denominado padre. Este estado expandido se considera como un estado visitado
del espacio de b√∫squeda.
El proceso de exploraci√≥n consiste en una ejecuci√≥n secuencial de los dos procesos (expansi√≥n
y generaci√≥n) hasta que se expanda un estado meta. El proceso de expansi√≥n se ejecuta tras la
comprobaci√≥n de que el estado a expandir no es una meta del problema. De forma que este tipo
de algoritmos se pueden considerar como algoritmos exhaustivos, ya que van explorando el
espacio de estados de forma exhaustiva hasta encontrar una soluci√≥n. Esto, puede dar lugar a
situaciones en el cual se tengan que generar todos los estado del problema para encontrar una
soluci√≥n, lo que puede hacer que el coste de encontrar una soluci√≥n sea prohibitivo para
problemas muy complejos. Existen, b√°sicamente, dos estrategias para explorar el espacio de
estados, en profundidad y en amplitud.

24Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
En la Figura, se presentan un ejemplo del √°rbol de b√∫squeda generado para resolver un problema
del 8-puzzle. En este caso, se ha aplica un algoritmo de b√∫squeda en amplitud, donde el espacio
de estados se van explorando por niveles de profundidad. Es decir, dado el nivel 0, compuesto
por el estado inicial, se generan cada uno de sus sucesores generando el nivel 1 del √°rbol de
b√∫squeda. A continuaci√≥n se realiza la expansi√≥n de cada uno de los nodos (estados) del nivel
1 siguiendo el orden en el cual han sido generados. En este caso la soluci√≥n se encuentra tras
expandir uno de los nodos del nivel 5 del √°rbol de b√∫squeda.
Profundidad
Sucesores
Estado Inicial
0
1
2
3
4
Meta
5
Figura 6: Ejemplo de b√∫squeda en amplitud para el 8-Puzzle
Los diferentes algoritmos de b√∫squeda no informada utilizan ciertas estructuras de datos para
conocer que nodos deben ser expandidos a continuaci√≥n. Estas estructuras de datos son
diferentes dependiendo de si los diferentes nodos (estados) del espacio de estados pueden ser
generados a diferentes niveles. Es decir, dependiendo si el algoritmo de b√∫squeda esta
recorriendo un grafo o un √°rbol. En base a estos, los algoritmos de b√∫squeda no informada
pueden utilizar dos estructuras de datos:
‚ñ™
Lista abierta: Esta estructura se corresponde con una pila o cola de estados dependiendo
de la estrategia que se utilice para expandir los nodos que son introducidos. Los nodos
25
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
insertados en esta estructura se denominan abiertos, debido a que han sido generados,
pero no expandidos.
‚ñ™ Lista cerrada: Esta estructura se corresponde con una lista enladada un una tabla hash,
donde se almancenan los nodos que han sido expandidos con el fin de comprobar si un
nodo ha sido generado previamente. Los nodos insertados en esta estructura se
denomina cerrados, debido a que han sido visitados o expandido previamente. Es decir,
sus sucesores ya han sido generados por el proceso de b√∫squeda.
3.2.1. Algoritmo de b√∫squeda en amplitud
El algoritmo de b√∫squeda en amplitud (Breadth First Search, BFS, en sus siglas en ingl√©s)[11]
se basa en expandir los nodos por niveles de profundidad. Es decir, cada nodo tiene un valor
que se corresponde con su nivel de profundidad en el √°rbol de b√∫squeda, de forma que su nivel
se corresponde con el nivel del padre (nodo generador) m√°s 1. Este tipo de proceso de
exploraci√≥n viene definido en parte por la estructura de datos utilizada para definir la lista abierta.
En este caso la lista abierta del algoritmo de b√∫squeda en amplitud se corresponde con una Cola
(First in, First Out, FIFO en sus siglas en ingl√©s) de forma que los sucesores del siguiente nivel
son extra√≠dos de la cola (expandidos) en el orden en el que fueron insertados.

26Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
Figura 7: Ejemplo del funcionamiento de un algoritmo de b√∫squeda en amplitud
La Figura 7 presenta un ejemplo del proceso de funcionamiento de un algoritmo en amplitud.
Como se puede observar el proceso de generaci√≥n se corresponde con las flechas negras de
izquierda a derecha y el proceso de expansi√≥n con las flechas rojas. Este algoritmo presenta una
gran ventaja a nivel de tiempo, si la soluci√≥n se encuentra niveles de profundidad bajos, pero
presenta una gran desventaja a nivel de memoria, ya que en situaciones donde cada nodo
tiene un m√°ximo de dos sucesores, el n√∫mero de nodos en la lista para cada nuevo nivel crece
exponencialmente, lo que puede suponer que el algoritmo no tenga memoria suficiente para
encontrar la soluci√≥n.
3.2.2. Algoritmo de b√∫squeda en profundidad
El algoritmo de b√∫squeda en profundidad (Deep First Search, DFS, en sus siglas en ingl√©s)[11]
se basa en expandir los nodos por niveles de profundidad. Es decir, tras expandir un nodo
(estado) del espacio de estados, se expande el primero de sus sucesores. De forma que el
proceso de exploraci√≥n va generando nodos en profundidad hasta que no es posible generar
m√°s sucesores de un nodo. Este tipo de proceso de exploraci√≥n viene definido en parte por la
27
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
estructura de datos utilizada para definir la lista abierta. En esta caso la lista abierta del algoritmo
de b√∫squeda en profundidad se corresponde con un Pila (Last in, First Out, LIFO en sus siglas
en ingl√©s) de forma que los sucesores de un nodo son insertados en orden inverso de generaci√≥n.
Siendo el √∫ltimo de los sucesores generados el siguiente nodo a expandir.
Figura 8: Ejemplo de funcionamiento de un algoritmo de b√∫squeda en profundidad
La Figura 8 presenta un ejemplo del proceso de funcionamiento de un algoritmo en profundidad.
Como se puede observar en la figura, el proceso de generaci√≥n se corresponde con las flechas
negras de derecha a izquierda y el proceso de expansi√≥n con las flechas rojas. En este algoritmo
el proceso de expansi√≥n profundiza en el √°rbol de b√∫squeda de forma recursiva hasta que no se
pueden generar m√°s sucesores. A continuaci√≥n el algoritmo vuelve hacia atr√°s (Backtraking) de
modo que se repita el mismo proceso para cada uno de los nodos hermanos del √∫ltimo nodo
expandido. Este algoritmo presenta una gran ventaja a nivel de memoria ya que necesita una
cantidad m√≠nima de espacio para el almacenamiento de los nodos generados aunque presenta
una desventaja a nivel de tiempo, ya que si la soluci√≥n se encuentra a baja profundidad muy a
la derecha del √°rbol de b√∫squeda se tardar√° mucho si la profundidad del √°rbol del b√∫squeda es
muy elevada. Debido a su naturaleza recursiva, s√≥lo es necesario almacenar los nodos
generados durante el camino de b√∫squeda que a√∫n no han sido expandidos, lo cual disminuye
el espacio de almacenamiento, pero incrementa la complejidad del proceso de b√∫squeda de
repetidos, haci√©ndolo imposible en algunas situaciones.

28Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
Con el fin de disminuir el coste temporal del proceso de b√∫squeda, este algoritmo puede ser
modificado incluyendo un l√≠mite de profundidad iterativo, de forma que el algoritmo s√≥lo busca
hasta una determinada profundidad m√°xima. De forma que s√≥lo se puedan expandir nodos hasta
una determinada profundidad. Aunque esta variaci√≥n puede disminuir el tiempo de b√∫squeda,
puede llevar a situaciones en las cuales no se encuentre una soluci√≥n al problema, debido a que
esta se encuentre a mayor profundidad.
3.2.3. Algoritmos de b√∫squeda iterativa
Los dos algoritmos descritos anteriormente pueden ser combinados con el fin de unificar la
ventajas de ambos y evitar algunos de sus problemas que presenta. Su combinaci√≥n da lugar a
dos nuevos algoritmos de b√∫squeda ciega o no informada:
‚ñ™
El algoritmo de profundidad iterativa (Iterative Deep First Search, IDFS en sus siglas en
ingl√©s) consiste en realizar b√∫squeda en profundidad repetidamente sobre un √°rbol de
profundidad incremental. Es decir primero se realiza una b√∫squeda a profundidad 1, luego
a profundidad 2, luego en profundidad 3 y as√≠ sucesivamente hasta que se encuentra una
soluci√≥n. El incremento en el nivel de profundidad no tiene por que ser lineal, se puede
hacer por ejemplo un incremento exponencial.
‚ñ™
El algoritmo de profundidad iterativa (Iterative Breath First Search, IBFS en sus siglas en
ingl√©s) consiste en realizar b√∫squeda en profundidad repetidamente sobre un √°rbol de
anchura incremental. Es decir primero se realiza una b√∫squeda a profundidad con
anchura 1, luego con anchura 2, luego con anchura 3 y as√≠ sucesivamente hasta que se
encuentra una soluci√≥n. Al igual que en el caso anterior, el incremento en el n√∫mero de
succesores (anchura) no tiene por que ser lineal, se puede hacer por ejemplo un
incremento exponencial.
3.2.4. Algoritmo de b√∫squeda bidireccional
La b√∫squeda bidireccional (Bidirectional Search, BS en sus siglas en ingl√©s)[12] consiste en
realizar dos b√∫squeda simultaneas. Una desde el estado inicial hasta el estado meta y otra desde
el estado meta hasta el estado inicial. En este algoritmo, el proceso de b√∫squeda finaliza cuando
ambos procesos expanden el mismo estado intermedio. A pesar de que parece un algoritmo muy
√∫til, presenta dos importante problemas:
‚ñ™
Definici√≥n del estado meta: En algunos problemas es imposible definir un √∫nico estado
meta, debido a que existen un conjunto de posibles estados metas. Esto hace que sea
29
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
necesario definir una funci√≥n de generaci√≥n de estados metas y otra que elija que estado
meta utilizar en base a alg√∫n criterio.
‚ñ™
Definici√≥n de la funci√≥n de identificaci√≥n: Para la utilizaci√≥n de este algoritmo es necesario
definir un funci√≥n de identificaci√≥n que permita identificar aquellos estados que han sido
generados por ambos algoritmo con el fin de parar el algoritmo de b√∫squeda y construir
la soluci√≥n. Este proceso implica nuevas estructuras de datos y procesos de
comprobaci√≥n de estados en ambos algoritmo. Por ejemplo, si los algoritmos son
ejecutados de forma simultanea en diferentes hilos de ejecuci√≥n, estos deben esperarse
mutuamente cuando se hacen las comprobaciones entre los nuevos estados expandidos.
En algunos casos, este proceso puede aumentar la complejidad del algoritmo.
Figura 9: Ejemplo de funcionamiento de un algoritmo de b√∫squeda bidireccional

30Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
En la Figura 9 se presenta un ejemplo del funcionamiento de un algoritmo de b√∫squeda
bidireccional. En este caso tenemos dos algoritmos que van generado nodos de forma
simultanea hasta que ambos generan el mismo nodo. En este ejemplo, se puede observar que
el s√©ptimo sucesor de la b√∫squeda iniciada en el estado inicial se corresponde con el sexto
sucesor de la b√∫squeda comenzada en la meta. Cada vez que se genera un sucesor en uno de
los dos nodos se debe comprobar si esta nodo ha sido generado previamente por la b√∫squeda
contraria. Normalmente estos algoritmos utilizan una lista cerrada compartida con el fin de
detectar nodos repetidos que se corresponde con la frontera de ambos algoritmos y que pueden
ser utilizados para generar una soluci√≥n. Normalmente los dos algoritmos utilizados en la
b√∫squeda suelen ser del mismo tipo, pero existen aproximaciones que utilizan diferentes tipo de
algoritmos.
Los cinco algoritmos de b√∫squeda no informada descritos en este cap√≠tulo son los ejemplos m√°s
importante de esta familia de algoritmos de b√∫squeda, se les considera como los algoritmos
cl√°sicos de b√∫squeda no informada. Aunque existe muchas otras versiones que incluyen mejoras
para optimizar su funcionamiento y resolver algunos de los problemas que presentan. Algunos
ejemplos son la b√∫squeda mediante islas, que es una mejora sobre la b√∫squeda bidireccional; la
b√∫squeda de coste uniforme, donde los nodos son expandidos en base al coste de las acciones
(las acciones tienen coste no unitario) que se usan para generar los nodos.
3.3 B√∫squeda informada
La b√∫squeda informada o heur√≠stica [13] es un tipo de b√∫squeda en el espacio de estados
donde se utiliza alg√∫n tipo de informaci√≥n del problema con el fin de minimizar el coste de
encontrar una soluci√≥n mediante la introducci√≥n de una funci√≥n que gu√≠a el proceso de b√∫squeda.
Esta funci√≥n gu√≠a, denominada funci√≥n heur√≠stica[14], calcula de forma estimada el coste que
supone alcanzar el nodo meta (soluci√≥n). Esta funci√≥n sirve para definir el orden en que los nodos
generados son almacenados en la lista abierta, de forma que los nodos con menor coste ser√°n
los primeros en ser expandidos. De forma que el orden de expansi√≥n de los estados ya no se
realizar√° de forma sistem√°tica en base a su posici√≥n en el √°rbol de b√∫squeda, sino mediante el
coste calculado por la funci√≥n heur√≠stica. Este tipo de algoritmos fueron creados con el fin de
minimizar el coste de b√∫squeda de los algoritmos no informados en problemas con un espacio
de estados extremadamente grande, as√≠ como para asegurar la obtenci√≥n de la soluci√≥n √≥ptima
en el caso de que existieran m√∫ltiples soluciones a un problema. Por ejemplo, imaginemos que
31
¬© StructuraliaInteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
queremos resolver un problema en el juego del Ajedrez, el tama√±o el espacio de estados es de
1047 estados. En el hipot√©tico caso de que pudi√©ramos generar 3 billones de nodos por segundo
y teniendo un espacio de memoria infinito, se tardar√≠an 1030 a√±os en expandir de forma completa
el espacio de b√∫squeda. Probablemente encontrar un soluci√≥n, no implicar√≠a expandir de forma
compleja el espacio de b√∫squeda, pero tal vez supondr√≠a alrededor de 100 a√±os en el caso de
que tuvi√©ramos muchas suerte. Pero, el proceso de b√∫squeda se puede complicar mucho m√°s,
si queremos obtener la soluci√≥n √≥ptima de entre las diferentes posibles soluciones al problema.
La soluci√≥n √≥ptima a un problema es una soluci√≥n factible que da el valor
m√°s favorable de la funci√≥n objetivo. En el caso de la b√∫squeda informada se
puede definir la soluci√≥n √≥ptima c√≥mo aquella soluci√≥n con el menor coste.
Para poder diferenciar la calidad de las distintas soluciones de un problema y conseguir encontrar
la soluci√≥n √≥ptima, es necesario introducir el concepto de coste. Para poder utilizar el concepto
de coste, es necesario introducir un coste asociado a cada uno de los operadores generando
dos posibles tipos de problemas de b√∫squeda informada:
‚ñ™
B√∫squeda con costes unitarios: Este es el tipo de b√∫squeda m√°s sencilla y asume que el
coste de todas las acciones es igual a 1.
‚ñ™
B√∫squeda con costes no unitarios: Este es el tipo m√°s complicado y cada uno de los
operadores tiene un coste diferente. Este coste puede ser global al tipo de operador o
depender de alg√∫n tipo de s√≠mbolo que representa alguna caracter√≠stica del entorno y
que puede ir variando en base a los operadores seleccionado durante el proceso de
b√∫squeda incrementando la complejidad del proceso de b√∫squeda.
Como describimos anteriormente, la funci√≥n heur√≠stica h(n) se puede definir como una funci√≥n
que permite estimar el coste (com√∫nmente el n√∫mero de acciones que deben ser ejecutadas)
desde un determinado estado hasta un estado meta (soluci√≥n). La calidad de esta funci√≥n es
muy importante, ya que puede suponer la diferente entre encontrar o no una soluci√≥n a un
problema. Una funci√≥n heur√≠stica con poco conocimiento del problema o con un conocimiento
err√≥neo podr√≠a guiar la b√∫squeda a regiones del espacio de b√∫squeda donde no existe una
soluci√≥n, produciendo un proceso de b√∫squeda peor que si estuvi√©ramos resolviendo le
problema mediante b√∫squeda no informada. En cambio, si tuvi√©ramos conocimiento perfecto del

32Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
problema, podr√≠amos guiar la b√∫squeda hacia la soluci√≥n descartando todos aquellos caminos
con mayor coste, eligiendo en cada expansi√≥n el estado de menor coste, y encontrando
finalmente la soluci√≥n √≥ptima en tiempo lineal.
El proceso de definici√≥n de funciones heur√≠sticas es muy complejo incluso cuando se tiene
conocimiento perfecto del problema y m√°s a√∫n si se intenta realizar de forma autom√°tica. Una
de las propiedades m√°s importantes a la hora de definir una funci√≥n heur√≠stica es la admisibilidad.
Se dice que una funci√≥n heur√≠stica h(n) es admisible si y s√≥lo si el coste para cada uno de los
estados del espacio de estados es siempre menor o igual al coste real. Es decir, una funci√≥n
heur√≠stica es admisible si nunca sobreestima el coste de alcanzar un estado meta. Algunos
ejemplos de funciones heur√≠sticas ampliamente utilizadas son:
‚ñ™
Distancia euclidea: Es la distancia "ordinaria" entre dos puntos de un espacio eucl√≠deo,
la cual se deduce a partir del teorema de Pit√°goras. Este tipo de funci√≥n heur√≠stica es
muy utilizada en problemas en los que hay que encontrar el camino entre dos puntos en
un espacio bidemensional.
‚ñ™
Distancia de Manhattan: Es la distancia entre dos puntos calculada como la suma de las
diferencias (absolutas) de sus coordenadas. Al igual que la anterior, este tipo de funci√≥n
heur√≠stica es muy utilizada en problemas en los que hay que encontrar el camino entre
dos puntos en un espacio bidimensional.
33
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
Figura 10: Ejemplo de c√°lculo del coste mediante la utilizaci√≥n de diferentes funciones heur√≠sticas
En la Figura 10, se presenta un ejemplo real sobre el callejero de la ciudad de Madrid. De forma
que queremos estimar el coste desde el punto en la parte inferior hasta el punto en la parte
superior del mapa. Para ellos vamos a utilizar los dos ejemplos de funciones heur√≠sticas descritas
anteriormente. En este caso, la distancia eucl√≠dea se corresponde con la l√≠nea roja, cuyo coste
es admisible ya que es menor que el coste real. Mientras que la distancia de Manhattan puede
ofrecer varios posibles valores debido a que existen m√∫ltiples maneras de conectar los dos
puntos del mapa. En este caso la distancia de Manhattan viene dada por los caminos azul y
verde. Como podemos observar en la imagen, la distancia euclidea parece que calcula un valor
menor, pero tal vez la distancia de Manhattan ofrece un valor m√°s cercano a la realidad, que
puede mejorar el proceso de b√∫squeda.
3.3.1. Algoritmo de b√∫squeda Voraz
El algoritmo Voraz o Avaricioso (Gready Best First Search, GBFS en sus siglas en ingl√©s)[11] se
basa en la ordenaci√≥n de los nodos generados en base al valor calculado por la funci√≥n heur√≠stica
h(n). En este caso, la funci√≥n h(n) calcula el coste de aplicar la siguiente acci√≥n sobre el nodo n,
de forma que aquellos nodos que tengan un coste menor se colocan al principio de la lista abierta.
¬© Structuralia
34Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
Se podr√≠as decir que este algoritmo explora siempre primero aquellos nodos cercanos al nodo n
que tienen menor coste.
Figura 11 - Ejemplo de aplicaci√≥n del Algoritmo Voraz
En la Figura 11, se presenta un ejemplo de c√≥mo se aplicar√≠a el algoritmo voraz. En este caso,
el algoritmo utilizar√≠a el valor inmediato de los sucesores. Para el nodo n0, se generar√≠an tres
nodos sucesores (n1, n2, y n3) cuyos valores heur√≠sticos ser√≠an respectivamente (5, 60 y 10).
De forma que el algoritmo voraz elegir√≠a el nodo n1 debido a que su valor heur√≠stico es h(n1) =
5. A continuaci√≥n, el algoritmo descartar√≠a el nodo n1, debido a que su sucesores tienen valores
heur√≠sticos muy grandes, de forma que el siguiente nodo a expandir ser√≠a el nodo n3, que nos
llevar√≠a directamente a la soluci√≥n (n0 ‚Üí n3 ‚Üí n4 ‚Üí n2 ‚Üí n5).
3.3.2. Algoritmo de b√∫squeda Mejor Primero
El algoritmo de Mejor Primero (Best First Search, BFS en sus siglas en ingl√©s) [12] se basa en la
ordenaci√≥n de los nodos generados en base al valor calculado por la funci√≥n heur√≠stica h(n) que
calcula una estimaci√≥n del coste entre el estado n y uno de los posibles estados meta. Los nodos
generados durante el proceso de expansi√≥n son insertados en una lista ordenada por coste de
menor a mayor, donde los nodos con mejor coste se encuentran en la cabecera de la lista y los
nodos de mayor coste se encuentran en la cola. Este algoritmo funciona de forma similar a un
algoritmo en amplitud (BFS) pero incluyendo un proceso de ordenaci√≥n de la lista abierta tras
35
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
cada inserci√≥n. De forma que este algoritmo siempre va a expandir en primer lugar aquellos
estados con menor coste.
3.3.3. Algoritmo de b√∫squeda A*
El algoritmo A*[15] se basa en la ordenaci√≥n de los nodos generados en base al valor calculado
con la funci√≥n de evaluaci√≥n denominada f(n), es decir funciona de forma similar a una algoritmo
de Mejor Primero pero utilizando otro tipo de funci√≥n de evaluaci√≥n. Los algoritmos descritos
anteriormente s√≥lo utilizan diferentes tipos de funci√≥n heur√≠stica para evaluar los nodos
generados y elegir aquel con menor coste con el fin de acercarse a la soluci√≥n. Pero en algunos
casos es necesario elegir un nodo con mayor coste con el fin de conseguir una soluci√≥n mejor o
encontrar una soluci√≥n que puede que no est√° disponible eligiendo el nodo de menor coste. El
algoritmo A* introduce un nuevo tipo de funci√≥n de evaluaci√≥n con el fin de calcular de forma m√°s
eficiente el coste real de la soluci√≥n cuando un determinado nodo. Esta funci√≥n de evaluaci√≥n
combina dos funciones:
ùëì(ùëõ) = ùëî(ùëõ) + ‚Ñé(ùëõ)
‚ñ™
Una funci√≥n de coste g(n) que se corresponde con el coste del camino explorado, que
se corresponde con el coste real hasta el nodo n que ha sigo generado y que consiste el
sumar el coste del operador que ha generado el nodo al coste del nodo padre. Este valor
es un valor perfecto y se calcula mediante un funci√≥n del tipo g(n).
‚ñ™
Una funci√≥n heur√≠stica h(n) que calcula el coste del camino inexplorado, que se
corresponde con el coste desde el nodo n hasta el nodo meta. Este coste debe ser
calculado utilizando alg√∫n tipo de informaci√≥n espec√≠fica del problema a resolver. Este
valor se corresponde con una estimaci√≥n del coste futuro para resolver el problema.
3.4 B√∫squeda local
La b√∫squeda local es un tipo de b√∫squeda en el espacio de soluciones donde se utiliza una
funci√≥n de evaluaci√≥n o fitness que nos permite evaluar la calidad de cada soluci√≥n. Es decir,
este tipo de algoritmos generan una soluci√≥n inicial de forma aleatoria e intentan optimizarla
mediante la aplicaci√≥n de una serie de operaciones con el fin de mejorar la calidad de la soluci√≥n
con respecto a un conjunto de objetivos que tienen que ser maximizados o minimizados (existen
¬© Structuralia
36Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
algoritmos que optimizan m√∫ltiples soluciones de forma simultaneas). Estas operaciones dan
lugar a la generaci√≥n de nuevas soluciones que espacialmente se encuentran muy pr√≥ximas a
la soluci√≥n utilizada para generarlas (las diferencias desde el punto de vista de la representaci√≥n
de la soluci√≥n son muy peque√±as).
El proceso de funcionamiento de este tipo de algoritmos se puede definir como un proceso de
optimizaci√≥n matem√°tica donde los mejores individuos (soluciones) son seleccionados de un
conjunto de posibles individuos en base a un determinado criterio. En este caso los algoritmos
de b√∫squeda local utilizan esos individuos (poblaci√≥n) para generar individuos de mejor calidad
con el fin de encontrar la soluci√≥n √≥ptima o acercarse a ella lo m√°s posible.
3.4.1. Algoritmos gen√©ticos
Los algoritmos gen√©ticos[16][17] es un m√©todo de optimizaci√≥n matem√°tica basado en el proceso
evolutivo de los organismos vivos. Este proceso se basa en los principios de la selecci√≥n natural
enunciados por Darwin en 1859, donde los diferentes individuos de una especie mejoran sus
caracter√≠sticas mediante un proceso continuo de evoluci√≥n a trav√©s del cruzamiento de individuos
y la aparici√≥n de mutaciones aleatorias. Este proceso puede ser modelado como un algoritmo de
b√∫squeda local mediante una poblaci√≥n de individuos (instancias), cada uno de los cuales
representa una soluci√≥n factible del problema a resolver con un determinado factor de calidad.
En base a este factor de calidad los individuos son combinados (cruzados) entre s√≠ para generar
una nueva poblaci√≥n de individuos que remplace a la actual. De forma que aquellos individuos
con mayor calidad tendr√°n una mayor probabilidad de ser elegidos y aquellos con menor calidad
no ser√°n elegidos para el proceso de combinaci√≥n. Adem√°s, con el fin de evitar la falta de
variabilidad de los nuevos individuos se introducen variaciones aleatorias sobre los individuos
mediante mutaciones. El proceso de b√∫squeda es guiado por la calidad de los individuos
favoreciendo el cruzamiento de los mejores individuos de cada poblaci√≥n produciendo una
exploraci√≥n de las zonas m√°s prometedores del espacio de b√∫squeda siempre convergiendo
hasta la soluci√≥n √≥ptima del problema siempre y cuando la funci√≥n que calcula la calidad de un
individuo sea capaz de calcular este valor con precisi√≥n.
El funcionamiento de los algoritmos gen√©ticos se puede describir mediante el m√°s simple de sus
variaciones denominado Algoritmo Gen√©tico Can√≥nico cuyo pseudoc√≥digo se presenta en la
Figura 12. Este algoritmo consiste en un bucle de evoluci√≥n que es iniciado con la generaci√≥n
de la poblaci√≥n aleatoria de individuos cuya calidad es calculada mediante la funci√≥n de fitness.
A continuaci√≥n, se ejecutar√°n un conjunto de episodios de evoluci√≥n donde los individuos con
37
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
mejor calidad son seleccionados de forma aleatoria de dos en dos para ser cruzados generando
dos nuevos individuos, sobre cada uno de los cuales se aplicar√° un operador de mutaci√≥n. El
resultado de cada uno de los episodios de evoluci√≥n consistir√° en una nueva poblaci√≥n de
individuos que ser√° utilizada en el siguiente episodio de evoluci√≥n. El problema global de
evoluci√≥n finalizar√° cuando se consiga alcanzar el criterio de parada. El objetivo del algoritmo es
conseguir la soluci√≥n √≥ptima, pero los algoritmos gen√©ticos no aseguran la obtenci√≥n de la
soluci√≥n √≥ptima. El objetivo suele ser ejecutado un n√∫mero m√°ximo de episodios de evoluci√≥n.
Figura 12: Pseudoc√≥digo de un algoritmo gen√©tico can√≥nico
Definici√≥n del individuo
Un elemento muy importante a la hora de utilizar algoritmos gen√©ticos consiste en definir la
codificaci√≥n de los individuos que representan las posibles soluciones del problema. La
codificaci√≥n de los individuos es la estructura mediante la cual se representan las soluciones al
problema y que toma su estructura y nomenclatura de los componentes b√°sicos mediante los
cuales est√°n construidos los seres vivos. Las soluciones (denominadas cromosomas) son
representado por una secuencia de par√°metros o variables (que son denominados genes). Los
valores de los par√°metros son definidos mediante un alfabeto que normalmente est√° formado
por dos elementos (0 y 1) aunque tambi√©n es com√∫n ver alfabetos con m√°s de dos elementos.
Pero en ambos casos los elementos del alfabeto son num√©ricos. Cada uno de estos individuos
es evaluado mediante una funci√≥n de fitness que calcula la calidad del individuo con respecto a
un determinado objetivo. Esta funci√≥n es especifica para cada problema y siempre devuelve un
valor decimal, normalmente entre 0 y 100.

38Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
Operaciones
Las operaciones se corresponde con acciones que se aplican para generar nuevos individuos.
Estas operaciones se basan, al igual que los dem√°s conceptos de los algoritmos gen√©ticos, en
la teor√≠a gen√©tica. Las dos operaciones b√°sicas son cruzamiento y mutaci√≥n:
Cruzamiento
Es la operaci√≥n mediante la cual se combinan las variables que componen los cromosomas de
dos individuos para generar uno o dos nuevos individuos. El proceso de cruzamiento permite
combinar las variables de los cromosomas de diferente manera. La m√°s com√∫n es el cruzamiento
simple que consiste en cortar los cromosomas de ambos individuos por un √∫nico punto y los
grupos de genes se intercambian generando as√≠ dos nuevos individuos, como se muestra en la
Figura 13. Este tipo de proceso puede modificarse utilizando m√∫ltiples puntos de corte.
Figura 13: Ejemplo de proceso de cruzamiento
Aunque es posible realizar multiples cortes o incluso en algunos casos incluir m√°s de dos
individuos para el proceso de cruzamiento.
Mutaci√≥n
Es la operaci√≥n mediante la cual se aplicaci√≥n alg√∫n tipo de variaci√≥n en el valor de ciertas
variables del cromosoma de forma aleatoria. Comumente, el operador de mutaci√≥n modifica el
valor de n variables elegidas de manera aleatoria como se puede observar en la Figura 14,
donde las variables 3, 5, 8, 9 y 10 has sido modificadas.
39
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
Figura 14: Ejemplo de proceso de mutaci√≥n
Existen m√∫ltiples variaciones de los algoritmos gen√©ticos, los cuales incluyen otros tipo de
operadores, as√≠ como diferentes mecanismos de selecci√≥n de individuos o generaci√≥n de
mutaciones. Adem√°s existen diferentes tipos de algoritmos multi-objetivo basados en algoritmos
gen√©ticos los cuales intentan buscar una soluci√≥n optimizando m√∫ltiples objetivos que tienes que
ser maximizados o minimizados. Esto implica que tendremos m√∫ltiples funciones de fitness, una
para cada objetivo.
3.4.2. B√∫squeda tab√∫
El principal problema de los algoritmos de b√∫squeda local es su facilidad para queda atrapado
en ciertas zonas del espacio de b√∫squeda debido a que est√°n continuamente generando
soluciones similares de forma c√≠clica. Estas zonas son partes del espacio de b√∫squeda donde
existe una soluci√≥n de muy buena calidad, pero alejada de la soluci√≥n √≥ptima, que una vez
alcanzada no permiten al algoritmo escapar mediante la generaci√≥n de nuevas soluciones. Se
denominan m√°ximos o m√≠nimos locales dependiendo del tratamiento que se les est√©n dando a
los objetivos del problema (maximizar o minimizar). En la Figura 15 se presenta un ejemplo de
superficie de una funci√≥n objetivo para un problema de optimizaci√≥n donde existe un m√°ximo
local donde el proceso de b√∫squeda local puede quedar atrapado antes de acercarse a la
soluci√≥n √≥ptima. Con el fin de evitar este tipo de situaciones surgieron los algoritmos de b√∫squeda
tab√∫.

40Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
Figura 15: Superficie de una funci√≥n objetivo de un problema de optimizaci√≥n combinatoria
Este tipo de algoritmos son un m√©todo de optimizaci√≥n matem√°tica basados en la utilizaci√≥n de
una estructura de memoria que almacena las soluciones generadas previamente con el fin de
que el algoritmo de b√∫squeda no vuelva a visitar o generar estas soluciones evitando quedarse
atrapados en un m√≠nimo o m√°ximo local. Para ello se utiliza un procedimiento de b√∫squeda por
vecindades que permite generar nuevas soluciones mediante la utilizaci√≥n de una funci√≥n de
vecindad. Esta funci√≥n permite generar soluciones que pertenecen a la misma vecindad a partir
de otra soluci√≥n, de forma que cada soluci√≥n puede pertenecer a m√∫ltiples vecindades. Con el
fin de poder explorar la mayor cantidad de regiones del espacio de b√∫squeda se utiliza la
estructura memoria que modifica el resultado de la funci√≥n de vecindad para cada soluci√≥n a
medida que la b√∫squeda progresa. Es decir, elimina soluciones que ya han sido exploradas
previamente con el fin de no quedar atrapado en una zona del espacio de b√∫squeda. La
estructura de memoria puede utilizarse de dos maneras diferentes:
‚ñ™
Memoria a corto plazo: La informaci√≥n insertada en la lista tab√∫ solo se mantiene
almacenada durante n iteraciones, es decir para cada soluci√≥n se indica el n√∫mero de
iteraci√≥n en la que fue insertado elimin√°ndose al pasar n iteraciones. De esta manera el
tama√±o de la lista tab√∫ est√° siempre controlada.
‚ñ™
Memoria a largo plazo: Todas las soluciones generadas son almacenadas por la lista
tab√∫, lo que implica un gasto excesivo de memoria y aumenta el tiempo a la hora de
detectar soluciones previamente insertadas cuando el tama√±o de la lista es muy elevado.
41
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
3.5 Otros tipos de t√©cnicas basadas en b√∫squeda
3.5.1. Adem√°s de las diferentes t√©cnicas de b√∫squeda que hemos descrito, existen otros tipos
de t√©cnicas basadas en b√∫squeda cuya complejidad es superior debido a ciertas simplificaciones
aplicadas en base a ciertos factores como un tiempo de b√∫squeda limitado, un mayor n√∫mero de
agentes de b√∫squeda, etc.
3.5.2. B√∫squeda en tiempo real
Los algoritmos de b√∫squeda informada descritos en la secci√≥n 3.3 de este documento tienen
ciertas limitaciones cuando el espacio de b√∫squeda es extremadamente grandes como por
ejemplo en problemas de navegaci√≥n o los videojuegos donde es necesario obtener una soluci√≥n
en tiempo limitado. Actualmente existen dos grupos de algoritmos que son capaces de resolver
problemas con estas caracter√≠sticas.
‚ñ™
Algoritmos incrementales: Son algoritmos de b√∫squeda que reutilizan informaci√≥n de
b√∫squedas previas para encontrar soluciones de forma mucho m√°s r√°pida a problemas
similares de mayor complejidad que resolviendo del problema desde el estado inicial [19].
‚ñ™
Algoritmos en tiempo real: Son algoritmos de b√∫squeda tradicionalmente utilizados para
resolver problemas relacionados de complejidad muy elevada que deben interactuar con
el entorno en tiempo real, para ello combinan una fase de planificaci√≥n (b√∫squeda) y una
fase de ejecuci√≥n. En la fase planificaci√≥n realizan una b√∫squeda en profundidad limitada
para definir los siguiente n movimientos (acciones) mientras que en la fase de ejecuci√≥n
se realiza la ejecuci√≥n del primer movimiento de la secuencia de acciones recogiendo
informaci√≥n real del entorno que es utilizada en la siguiente fase de planificaci√≥n. Los
algoritmos m√°s utilizados de este tipo son: (1) Real-Time A* (RTA* es sus siglas en
ingl√©s)[20]; y (2) Learning Real-Time A* (LRTA* en sus siglas en ingl√©s)[20].
3.5.3. B√∫squeda con adversario
Los algoritmos de b√∫squeda con adversario se utilizan para generar soluciones en entornos
donde el proceso de b√∫squeda implica al menos dos agentes cuyas acciones producen
variaciones en el entorno. Los algoritmos m√°s comunes est√°n basados en dos jugadores donde
el proceso de b√∫squeda simula los turnos de los jugadores mediante los niveles del √°rbol de
b√∫squeda. Los algoritmos m√°s utilizados de este tipo son:

42Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
‚ñ™
MinMax: Es un algoritmo de b√∫squeda con adversario para dos jugadores (Max o Min)
que busca minimizar la p√©rdida m√°xima esperada utilizando informaci√≥n perfecta del entorno.
El algoritmo utiliza dos jugadores (Min o Max) cada uno de los cuales realiza movimiento
independientes en un nivel del √°rbol, de que para el jugador Max se seleccionar√° la
jugada con la mejor puntuaci√≥n posible y para el jugador Min se seleccionar√° la jugada
con la menor puntuaci√≥n. El jugador Max siempre escoger√° la mejor jugada suponiendo
que el adversario, el jugador Min escoger√° la peor [21].
‚ñ™
Alfabeta: Es un algoritmo de b√∫squeda que mejora el funcionamiento del anterior
mediante la introducci√≥n de un tipo de poda, denominada poda alfabeta, que reduce el
significativamente el n√∫mero de nodos el √°rbol de b√∫squeda (n√∫mero de estados a
explorar es exponencial al n√∫mero de movimientos) [22].
4. CONCLUSIONES
En este tema se han presentado dos grandes grupos de t√©cnicas de Inteligencia Artificial
utilizadas para la resoluci√≥n autom√°tica de problemas. Como se puede observar el proceso de
resoluci√≥n no es completamente autom√°tico ya que para que ambas t√©cnicas funcionen
correctamente es necesario definir una serie de elementos b√°sicos que describen y acotan el
problema que queremos resolver. La correcta descripci√≥n de estos elementos puede ser la
diferencia a la hora de resolver o no el problema.
Por un lado hemos descrito el funcionamiento de diferentes t√©cnicas de razonamiento autom√°tico
las cuales nos permiten construir sistemas expertos que intentan simular el proceso de
razonamiento utilizadodo por los humanos para resolver problemas. Pero para permitir que estos
sistemas expertos funcionen es necesario definir como se va a modelar la informaci√≥n del
entorno y cuales son las reglas que se van a utilizar para inferir conclusiones. Una vez definida
toda esta informaci√≥n ser√° posible construir un sistema experto basado en alguno de los modelos
de razonamiento descrito que sea capaz de resolver problemas de un ambito espec√≠fico, es decir
este sistema no podr√° ser utilizado para nada m√°s. En caso de que queramos aumentar su
complejidad podr√≠amos incluir nuevos hechos o reglas pero no podr√≠amos moficiar el dominio
sobre el cual trabaja el sistema experto.
Por otro lado hemos descrito el funcionamiento de diferentes t√©cnicas de b√∫squeda (no
informada, informada, local, etc) las cuales nos permiten generar soluciones a cierto tipos de
43
Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
problemas mediante la utilizaci√≥n de una definici√≥n detallada de las caracter√≠sticas del dominio
a utilizar. En este caso, los algoritmos est√°n m√°s orientados a la resoluci√≥n de problemas de
ambito general de forma que se puedan definir las caracter√≠sticas b√°sicas del problema y las
posibles acciones que pueden aplicar y cualquiera de los algoritmos ser√° capaz de resolver el
problema. Esto no es del todo cierto, ya que dependiendo del tipo de algoritmo habr√° que modelar
la informaci√≥n de una manera especifica en base a su funcionamiento. Pero los algoritmos
podr√°n ser utilizados de forma general. Un ejemplo de la versatilidad de los algoritmos de
b√∫squeda es la planificaci√≥n autom√°tica, la cual es un √°rea de la inteligencia artificial que utiliza
b√∫squeda heur√≠stica para resoluci√≥n de problemas con independencia del dominio. Para ello, los
investigadores en esta √°rea han desarrollado diferentes tipo de heur√≠sticas gen√©ricas que pueden
aplicarse a cualquier tipo de problema convirtiendo a los sistemas de planificiaci√≥n en sistemas
independientes del dominio ya que para resolver un problema s√≥lo necesitan una definici√≥n
especifica del dominio (tipos y acciones) y una definici√≥n del problema (objetos y metas).
5. REFERENCIAS
[1] G. Ernst and A. Newell (1969), ‚ÄúGps: A case study in generality and problem solving‚Äù, ACM
Monograph Series. Academic Press, New York, NY, United State of America.
[2] Haugeland, John (1985). Artificial Intelligence: The Very Idea, Cambridge, Mass: MIT Press,
ISBN: 0-262-08153-9
[3] Jackson, Peter (1998). Introduction To Expert Systems (3rd edition), Addison Wesley, p. 2,
ISBN: 978-0-201-87686-4
[4] Buchanan, Bruce G. and Shortliffe, Edward H. (1984). Rule Based Expert Systems: The
Mycin Experiments of the Stanford Heuristic Programming Project (The Addison-Wesley series
in artificial intelligence). Boston, MA, USA: Addison-Wesley Longman Publishing Co.
[5] Antoni L. (2006). Logical Foundations for Rule-Based Systems (Studies in Computational
Intelligence) (Studies in Computational Intelligence), Springer-Verlag Berlin, Heidelberg ISBN:
3540291172
[6] Kolodner, J. (1993). Case-Based Reasoning. Morgan Kaufmann.
[7] Watson, I. (1997). Applying Case-Based Reasoning: Techniques for Enterprise
Systems. Morgan Kaufmann Publisher.

44Inteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
[8] Bellman R.E. and Zadeh L.A. (1970), Decision-Making in a Fuzzy Environment.
Management Science, 17.
[9] Zadeh, L.A. (1965). Fuzzy Sets. Information Control, volume 8 pp. 338-353.
[10] Russell, Stuart J.; Norvig, Peter (2002), "3.4 Uninformed search strategies", Artificial
Intelligence: A Modern Approach (2nd ed.), Prentice Hall.
[11] Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2001).
Introduction to Algorithms (2nd ed.). MIT Press and McGraw-Hill. pp. 531?539. ISBN:0-262-
03293-7.
[12] de Champeaux, Dennis (1983), Bidirectional heuristic search again, Journal of the ACM,
Volume 30(1) pp:22?32.
[13] Edelkamp, S. and Schroedl S. (2011). Heuristic Search: Theory and Applications Stefan
(1st Edition). ISBN: 9780080919737
[14] Pearl, J. (1984). Heuristics: intelligent search strategies for computer problem solving.
United States: Addison-Wesley Pub. Co., Inc., Reading, MA.
[15] Hart, P. E.; Nilsson, N. J.; Raphael, B. (1968). A Formal Basis for the Heuristic
Determination of Minimum Cost Paths. IEEE Transactions on Systems Science and Cybernetics
SSC4. volume 4(2), pp 100?107.
[16] Holland, J. H. (1975). Adaptation in Natural and Artificial Systems. Cambridge, MA:
MIT Press.
[17] Banzhaf, W.; Nordin, P.; Keller, R.; Francone, F. (1998). Genetic Programming: An
Introduction. San Francisco, CA: Morgan Kaufmann. ISBN:978-1558605107.
[18] Fred Glover (1986). Future Paths for Integer Programming and Links to Artificial
Intelligence. Computers and Operations Research. volume 13(5). pp 533?549.
[19] Koenig S.-, Likhachev M.; Liu Y.; Furci D. (2004). Incremental Heuristic Search in Artificial
Intelligence. Artificial Intelligence Magazine.
[20] Richard K. (1990). Real-time heuristic search. Artificial Intelligence. volume 42(2-3). pp
189?211.
[21] Nilsson, N.J. (1980). Principles of Artificial Intelligence. Tioga Publishing Company, Palo
Alto, CA
45
¬© StructuraliaInteligencia artificial ‚Äì Resoluci√≥n autom√°tica de problemas
[22] Edwards, D.J.; Hart, T.P. (1961). The Alpha-beta Heuristic. Massachusetts Institute of
Technology.

